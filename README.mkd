This repository serves as a log of my endeavour to learn to use and understand
the [Coq](https://coq.inria.fr/) proof assistant. It may contain proofs, attempts
at proofs, links to related resources (blogs, articles, papers, books), notes on
logic, type theory, formal verification, theorem proving, automated reasoning, and
much more.

I will try to only include things that seem useful, informative, interesting or cool,
things that I forget, and tips and warnings regarding the subtleties of Coq.
Therefore, if you want to learn Coq from scratch, I suggest you try one of the
resources listed [below](#useful-resources).

I do not claim completeness, correctness, consistency or usefulness of any
information contained herein.

![](http://i.creativecommons.org/p/zero/1.0/80x15.png)

---

-   [On Coq](#on-coq)
-   [Standard tactics](#standard-tactics)
-   [Encoding mathematical structures](#encoding-mathematical-structures)
-   [Useful resources](#useful-resources)
    -   [Blogs](#blogs)
-   [Libraries and plug-ins](#libraries-and-plug-ins)
-   [Applications](#applications)
    -   [Papers and articles](#papers-and-articles)
-   [Related languages, tools and stuff](#related-languages-tools-and-stuff)
    -   [Journals](#journals)
    -   [Conferences and workshops](#conferences-and-workshops)
    -   [Proof assistants, provers and languages](#proof-assistants-provers-and-languages)
    -   [SAT &amp; SMT solvers](#sat--smt-solvers)
    -   [Other tools](#other-tools)
    -   [Formal methods in practice](#formal-methods-in-practice)
    -   [Learning resources](#learning-resources)
-   [Type theory](#type-theory)
    -   [Dependent types](#dependent-types)
-   [Copyright](#copyright)

## On Coq

Coq is an interactive theorem prover and proof assistant based on an intuitionistic
constructive logic. The underlying formalism is called Calculus of Constructions
(CoC), with an extension to the Calculus of (Co-)Inductive Constructions. Its core is
written in OCaml.

<!-- *TODO:* Slap some papers on the formal stuff around here -->

## Standard tactics

Standard Coq contains many tactics for working with the proof state, some of which
may be confused easily. The documentation on tactics may be the most informative and
thorough part of the Coq reference manual, so it's worth a read if you're looking for
a way to make your proofs more concise. See the [Tactics Index](https://coq.inria.fr/distrib/current/refman/tactic-index.html)
and [Chapter 8: Tactics](https://coq.inria.fr/distrib/current/refman/Reference-Manual010.html)
in the reference manual.

The Ssreflect libary (see below) contains a more sensible and consistent set of
tactics. Although its syntax is very different from the Coq standard, don't let
this discourage you.

-   `intros` – The introduction pattern may contain destructive patterns. For
    instance, `intros [P Q]` applied to `P /\ Q -> P` would create two new
    hypotheses, `P, Q : Prop`. Similarly, `intros [P | Q]` on `P \/ ~P -> Q` would
    split the goal in two, `P : Prop |- Q` and `~P : Prop |- Q`. Any name can be
    replaced by a question mark to have a fresh one generated automatically.
-   `auto` and `trivial` try to find a combination of `intro`, `apply` and
    `assumption` that solves the goal to a certain depth. `trivial` only goes one
    step deep.
-   cool trick: duplicate a hypothesis – `assert (H' := H).` (equivalent to `pose
    proof H as H'.`)
-   `pose (ident := term)` – adds a local definition to the current context without
    performing any replacement; equivalent to `set (ident := term) in |-`
-   ex falso proofs
    -   `exfalso`
    -   `absurd H` – prove current goal _ex falso_ by proving `H` and `~H`
    -   `contradict H` – proof by contradiction using H; final form depends on the form
        of current goal and the hypothesis
    -   `contradiction` – find a contradiction in the current hypotheses
-   `tauto` – tactic for propositional tautologies
-   `firstorder` – tactic for first-order logic
-   `omega` – tactic for Presburger arithmetic

*Tacticals* (tactical combinators): can be combined

-   applying tactics in sequence – `T1; T2.`
    - tries to apply T2 to all subgoals generated by T1
-   applying tactics in parralel – `T; [T1 | T2 | ... | Tn].`
    -   applies `T` to the current goal, then `T1` to the first new subgoal, ...,
        `Tn` to the nth
-   TODO: `[> ... | ...]`

## Encoding mathematical structures

There are multiple approaches to encoding structures in Coq's calculus. The principal
ones are:

-   [modules](https://coq.inria.fr/cocorico/ModuleSystem) and module types,
-   (dependent) records, and
-   something else.

## Useful resources

-   [Official Coq documentation](https://coq.inria.fr/documentation)
    -   The official documentation is OK, quite comprehensive. The description of
        tactics is very good, there are few undocuments points.
    -   [Reference Manual](https://coq.inria.fr/distrib/current/files/Reference-Manual.pdf)
    -   [Tutorial](https://coq.inria.fr/distrib/current/files/Tutorial.pdf)
        -   A simple and straightforward introduction to basics of proofs using Coq
-   [Cocorico!](https://coq.inria.fr/cocorico/Home) – official wiki
-   The [coq-club](https://sympa.inria.fr/sympa/arc/coq-club) mailing list
-   B\. C. Pierce et al.: [_Software Foundations_](http://www.cis.upenn.edu/~bcpierce/sf/current/)
    – probably the best introduction into Coq and theorem proving available
-   A\. Chlipala: [_Certified Programming with Dependent Types_](http://adam.chlipala.net/cpdt/)
    – an awesome book to read after _Software Foundations_; a bit more advanced,
    slightly different topics; puts forth the idea of using automation whenever
    possible
-   I\. Sergey: [_Programs and Proofs: Mechanizing Mathematics with Dependent Types_](http://ilyasergey.net/pnp/) (draft)
-   [/r/coq](https://www.reddit.com/r/coq)
-   [Coq in a Hurry](https://cel.archives-ouvertes.fr/file/index/docid/475807/filename/coq-hurry.pdf)
-   [Introduction to the Coq proof-assistant for practical software
    verication](https://www.lri.fr/~paulin/LASER/course-notes.pdf) course notes
    -   Another tutorial, slightly more interesting; possibly outdated
-   [Coq'Art](http://www.labri.fr/perso/casteran/CoqArt/index.html) – the first ever
    book on Coq and CoC
    -   See also [Pierre Castéran's page](http://www.labri.fr/perso/casteran/) for
        _A Tutorial on [Co-]Inductive Types in Coq_ and _A Gentle Introduction to
        Type Classes and Relations in Coq_
-   the [nLab wiki](http://ncatlab.org/nlab/show/HomePage)
    -   [its page on Coq](http://ncatlab.org/nlab/show/Coq), for instance

### Blogs

-   [Poleiro](http://poleiro.info/)
-   [Gagallium](http://gallium.inria.fr/blog/) – blog of the [Gallium research team](http://gallium.inria.fr/) at Inria
-   Guillaume Claret's [Coq blog](http://coq-blog.clarus.me/)
-   [Coq en Stock](http://goto.ucsd.edu/~vrobert/coq-en-stock/blog/)
-   [_Homotopy Type Theory_ blog](http://homotopytypetheory.org/blog)
    -   [Modules for Modalities](http://homotopytypetheory.org/2015/07/05/modules-for-modalities)
        – an article on Coq's module system and universe polymorphism
-   [The Type Theory Podcast](http://typetheorypodcast.com/)

## Libraries and plug-ins

-   [Ssreflect and MathComp](http://ssr.msr-inria.inria.fr/)
    -   [_A Small Scale Reflection Extension for the Coq system_](https://hal.inria.fr/inria-00258384/en)
    -   [_Computing with Univalence_](http://dlicata.web.wesleyan.edu/pubs/lh122tttalks/lh12hdact-slides.pdf)
        (2008; slides)
-   [CoLoR](http://color.inria.fr/) – "a Coq Library on rewriting and termination"
-   [coq-ext-lib](https://github.com/coq-ext-lib/coq-ext-lib) – "a collection of
    theories and plugins that may be useful in other Coq developments"
-   [Equations](http://www.pps.univ-paris-diderot.fr/~sozeau/research/coq/equations.en.html)
    – dependent pattern matching
-   [Mtac](http://plv.mpi-sws.org/mtac/) – "a monad for typed tactic programming in Coq"
-   [cases plug-in](https://github.com/pilki/cases) – extended support for `S*Case`
    as featured in _Software Foundations_
-   [wilcoxjay/tactics](https://github.com/wilcoxjay/tactics) – some useful tactics
    by James Wilcox
-   ["A Formal Library for Elliptic Curves in the Coq Proof Assistant"](https://dx.doi.org/10.1007/978-3-319-08970-6_6)
    ([GitHub](https://github.com/strub/elliptic-curves-ssr))
-   [multinomials](https://github.com/strub/multinomials-ssr) – a Coq/SSReflect
    library for multinomials
-   [Coquelicot](http://coquelicot.saclay.inria.fr/) – library for real analysis
    -   C\. Lelay (2015): [_How to express convergence for analysis in Coq_](https://hal.inria.fr/hal-01169321)
-   [domain theory in Coq](http://rwd.rdockins.name/domains/)
-   [Coq.io](http://coq.io/) and others by [Guillaume Claret](http://claret.me/)
    ([GitHub](https://github.com/clarus))
-   [Cybele](http://cybele.gforge.inria.fr/) – "a powerful tool to write proofs by
    reflection in Coq"
-   [Verdi](https://github.com/uwplse/verdi) – "a framework for formally verifying
    distributed systems implementations in Coq"
-   [coq-haskell](https://github.com/jwiegley/coq-haskell)
    -   Applied: [coq-pipes](https://github.com/jwiegley/coq-pipes)
-   [CFML](http://www.chargueraud.org/softs/cfml/): Characteristic Formulae for ML
    – verification of correctness and amortized complexity of OCaml programs
    -   [A series of blog posts](http://gallium.inria.fr/~scherer/gagallium/formally-verified-complexity-with-cfml-part-1/)
        on the Gagallium blog on verifying complexity
-   [TLC](http://www.chargueraud.org/softs/tlc/): "a non-constructive library for Coq"
    – extensionality as an axiom, classical logic by default, etc.
-   [Verified Software Toolchain](http://vst.cs.princeton.edu/)
    -   tons of articles around this
    -   A\. W. Appel: [_Verified Software Toolchain_](https://www.cs.princeton.edu/~appel/papers/vst.pdf)
-   [Bedrock](http://plv.csail.mit.edu/bedrock/) (abandoned?)
    -   A\. Chlipala: [_The Bedrock Structured Programming System: Combining
        Generative Metaprogramming and Hoare Logic in an Extensible Program
        Verifier_](http://adam.chlipala.net/papers/BedrockICFP13/BedrockICFP13.pdf)
-   [Ynot](http://ynot.cs.harvard.edu/) (abandoned)
    -   A\. Chlipala et al.: [_Effective Interactive Proofs for Higher-Order
        Imperative Programs_](http://ynot.cs.harvard.edu/papers/icfp09.pdf)
-   ["Category Theory in Coq 8.5"](http://arxiv.org/abs/1505.06430) ([Bitbucket](https://bitbucket.org/amintimany/categories/); Coq Workshop 2014)
-   [CH2O](http://robbertkrebbers.nl/research/ch2o/) – formalization of ISO C11
    ([GitHub](https://github.com/robbertkrebbers/ch2o))
    -   ["Formalizing C in Coq"](https://coqpl.cs.washington.edu/wp-content/uploads/2014/12/ch2o.pdf)
        ([CoqPL 2015](https://coqpl.cs.washington.edu/))

## Applications

-   [CertiCrypt](http://certicrypt.gforge.inria.fr/) – Computer-Aided Cryptographic Proofs in Coq
    -   [_Formal certification of ElGamal encryption_](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.220.6617) (2008)
-   [CompCert](http://compcert.inria.fr/) – verified optimising compiler of
    a substantial subset of C99
-   [Verasco](http://compcert.inria.fr/verasco/) – verified static analyser
-   [JSCert: Certified JavaScript](http://jscert.org)
    -   [_A Trusted Machnised JavaScript Specification_](http://www.doc.ic.ac.uk/~gds/jscert_popl14.pdf)
        (2014; [slides](http://jscert.org/popol14))
-   [_A Machine-Checked Proof of the Odd Order Theorem_](http://www.cs.unibo.it/~asperti/PAPERS/odd_order.pdf)
-   [_A Reflexive Formalization of a SAT Solver in Coq_](https://www.lri.fr/~conchon/publis/lescuyer-conchon-tphols08.pdf)
    (2008)
-   [_Towards an effective formally certfied constraint solver_](http://cp2014.a4cp.org/sites/default/files/uploads/DuboisGotlieb-slides.pdf)
    (2014; slides)

### Papers and articles

-   [Heq: a Coq library for Heterogeneous Equality](http://sf.snu.ac.kr/gil.hur/Heq/)
-   [_Inductive-inductive definitions_](http://personal.cis.strath.ac.uk/fredrik.nordvall-forsberg/thesis/thesis.pdf)
-   [_Gradual Certified programming in Coq_](http://arxiv.org/abs/1506.04205)
-   [_An intro to (co)algebra and
    (co)induction_](http://homepages.cwi.nl/~janr/papers/files-of-papers/2011_Jacobs_Rutten_new.pdf)
-   [_Canonical Structures for the Working Coq User_](https://www.reddit.com/r/Coq/comments/3erkgv/canonical_structures_for_the_working_coq_user/)
-   [_Foundational Property-Based Testing_](https://hal.inria.fr/hal-01162898)
    – _QuickChick_, a port of _QuickCheck_ to Coq
-   J\. Gross: ["Coq Bug Minimizer"](https://coqpl.cs.washington.edu/wp-content/uploads/2014/12/bug-minimizer.pdf)
    (CoqPL 2015; [GitHub](https://github.com/JasonGross/coq-tools))

## Related languages, tools and stuff

Numerous journals, conferences and workshops, for instance, the _Journal of Automated
Reasoning_, POPL, and CoqPL. For tools, see also [page on the Coq website](https://coq.inria.fr/related-tools).

-   [_Homotopy Type Theory_](http://homotopytypetheory.org/) – the book and [the library](https://github.com/HoTT/HoTT)
    -   [Coq for Homotopy Type Theory](http://tabareau.fr/coqhott) – a dedicated research project
-   [UniMath](https://github.com/UniMath/UniMath) (_Univalent Foundations_)

Related ACM Special Interest Groups: [SIGPLAN](http://www.sigplan.org/),
[SIGLOG](http://siglog.org/) and [SIGACT](http://www.sigact.org/).

### Journals

(† denotes open-access journals)

-   _Journal of Automated Reasoning_
-   [_Logical Methods in Computer Science_](http://lmcs-online.org/index.php)&thinsp;†

### Conferences and workshops

I've divided the events into four disjoint categories, although, naturally, there
might be a significant overlap in the topics covered with events in other categories.

**Coq**

-   International Workshop on Coq for PL (CoqPL)
-   [Coq Workshop](https://coq.inria.fr/coq-workshop)

**Formal methods and automated reasoning**

This also includes computing theory and type theory in CS.

-   International Symposium on Formal Methods (FM)
-   NASA Formal Methods Symposium (NFM)
-   Conference on Certified Programs and Proofs (CPP)
-   Conference on Automated Verification (CAV)
-   Conference on Automated Deduction (CADE)
-   International Joint Conference on Automated Reasoning (IJCAR)
-   International Symposium on Automated Technology for Verification and Analysis (ATVA)
-   [International Workshop on Automated Verification of Critical Systems](http://www.cs.swan.ac.uk/avocs/) (AVoCS)
-   Interactive Theorem Proving (ITP) [2015](http://www.inf.kcl.ac.uk/staff/urbanc/itp-2015/)
-   Theorem Proving in Higher Order Logics (TPHOLs)
-   International Conference on Types for Proofs and Programs (TYPES)
-   Conference on Automated Reasoning with Analytic Tableaux and Related Methods (TABLEAUX)
-   International Conference on Rewriting, Deduction, and Programming (RDP)
-   [International Conference on Rewriting Techniques and Applications](http://rewriting.loria.fr/rta/) (RTA)
-   [International Conference on Typed Lambda Calculi and Applications](http://www.mimuw.edu.pl/tlca/) (TLCA)
-   [Formal Structures for Computation and Deduction](http://fscdconference.org/) (FSCD)
-   Higher-Dimensional Rewriting and Applications (HDRA)
-   Computer Security Foundations Symposium (CSF)
-   International Symposium on Mathematical Foundations of Computer Science (MFCS)

**Logic**

-   Federated Logic Conference (FLoC)
-   IEEE Symposium on Logic in Computer Science (LICS)
-   Annual Conference on Computer Science Logic (CSL)
-   International Conference on Logic Programming (ICLP)
-   [Conference on Theory and Applications of Satisfiability Testing](http://www.satisfiability.org/) (SAT)

**Programming languages**

-   Symposium on Principles of Programming Languages (POPL)
-   Summit on Advances in Programming Languages (SNAPL)
-   [The International Conference on Functional Programming](http://icfpconference.org/) (ICFP)
    -   [CUFP](http://cufp.org/) workshop
-   International Colloquium on Automata, Languages and Programming (ICALP)

**Meta**

-   [Computer Science Conferences](http://csconf.net) website
-   Microsoft Academic Search – [Top conferences in CS](http://academic.research.microsoft.com/?SearchDomain=2&entitytype=3)
-   [Top Crypto and Security Conferences Ranking](http://icsd.i2r.a-star.edu.sg/staff/jianying/conference-ranking.html)

### Proof assistants, provers and languages

-   [Lean](https://leanprover.github.io/) – a new theorem prover developed by Microsoft and CMU with
    automation support; looks a lot like Coq
-   [Agda](http://wiki.portal.chalmers.se/agda/pmwiki.php) – a (relatively) new, hip dependently-typed
    functional language and interactive theorem prover
    -   [Agda Tutorial](http://people.inf.elte.hu/divip/AgdaTutorial/Index.html)
-   [Idris](http://www.idris-lang.org/) – another new and hip "general purpose" language with dependent
    types, support for theorem proving and tactics; kind of like Coq-flavoured Haskell
-   [Dedukti](http://dedukti.gforge.inria.fr/) – proof checker based on the
    λΠ-calculus; tools for translation from other proof assistants available
-   [PRL Project (Nuprl)](http://www.nuprl.org/)
    -    [JonPRL](www.jonprl.org) ([GitHub](https://github.com/jonsterling/jonprl))
-   [Isabelle](https://isabelle.in.tum.de/) – great [Archive of Formal Proofs](http://afp.sourceforge.net/);
    small trusted meta-logical core, usually used along with HOL
    -   [Haskabelle](https://isabelle.in.tum.de/haskabelle.html)
    -   [Isar](https://isabelle.in.tum.de/Isar/)
    -   Isabelle/HOLCF – [paper](https://www21.in.tum.de/~nipkow/pubs/jfp99.html),
        [tutorial](https://isabelle.in.tum.de/library/HOL/HOLCF-Tutorial/document.pdf)
-   [HOL](http://www.cl.cam.ac.uk/research/hvg/HOL/) by Michael Gordon et al. – the
    original system for interactive theorem proving in higher-order logic
    -   [HOL Light](https://www.cl.cam.ac.uk/~jrh13/hol-light/) – small trusted core
    -   [HOL4](http://hol.sourceforge.net/)
-   [MINLOG](http://www.mathematik.uni-muenchen.de/~logik/minlog) – interactive proof
    assistant based on first-order natural deduction calculus
-   [ProofPower](http://www.lemma-one.com/ProofPower/index/) – based on higher-order
    logic
-   [Matita](http://matita.cs.unibo.it/)
-   [Mizar](http://mizar.org/)
-   [ACL2](https://www.cs.utexas.edu/users/moore/acl2/) (_A Computational Logic for
    Applicative Common Lisp_) – logic for modelling systems and a complementary
    prover; based on first-order logic
-   [Milawa](https://www.cs.utexas.edu/users/jared/milawa/Web/) – theorem prover for
    ACL2-like logic
    -   [_The reflective Milawa theorem prover is sound_](https://www.cs.utexas.edu/users/jared/publications/2015-jar-milawa.pdf) (2015)
-   [ATS](http://www.ats-lang.org/) (_Applied Type System_) – dependently typed
    functional languge
-   [F7](http://research.microsoft.com/en-us/projects/f7/) – extension of F#'s type
    system with refinement types, dependent types and π-calculus-style concurrency
-   [F\*](https://www.fstar-lang.org/) – "a new higher order, effectful programming
    language designed with program verification in mind"
-   [Eff](http://www.eff-lang.org/) – functional language with first-class effects
    and native handling of all kinds of computatinal effects without touching monads
-   [Twelf](http://twelf.org/wiki/Main_Page)
-   [Celf](https://clf.github.io/celf/)
-   [Prover9 and Mace4](https://www.cs.unm.edu/~mccune/prover9/) – and automated
    theorem prover for FOL and searchr for counterexamples, respectively

### SAT & SMT solvers

-   [MiniSat](http://minisat.se/)
-   [PicoSAT](http://fmv.jku.at/picosat)
-   [Z3](https://github.com/Z3Prover/z3)
-   [Alt-Ergo](http://alt-ergo.ocamlpro.com/) ([academic page](http://alt-ergo.lri.fr/))
-   [Yices](http://yices.csl.sri.com/) – non-free licence
-   [SBV](https://leventerkok.github.io/sbv/) – SMT-based Haskell verification
-   [funsat](https://hackage.haskell.org/package/funsat) – "a modern DPLL-style SAT
    solver" written in Haskell
-   [_Simple SMT solver for use in an optimizing compiler_](http://www.well-typed.com/blog/103/)
-   [SAT Competitions](http://www.satcompetition.org/)

### Other tools

-   [Why3](http://why3.lri.fr/) – platform for deductive reasoning on programs with
    support for many external provers
    -   [Gallery of verified programs](http://toccata.lri.fr/gallery/)
    -   [_Shepherd Your Herd of Provers_](http://research.microsoft.com/en-us/um/people/moskal/boogie2011/boogie2011_pg53.pdf) (2011)
-   [Alloy](http://alloy.mit.edu/alloy/index.html) – "a language and tool for relational models"
-   [Dafny](http://research.microsoft.com/en-us/projects/dafny/) – "a language and
    program verifier for functional correctness"
-   [rise4fun](http://rise4fun.com/) – a collection of numerous tools, i.a. for
    program and algorithm analysis and verification, by Microsoft Research, CMU and
    others that you can try right on the web page
-   [Profound](http://chaudhuri.info/software/profound/) – "an experiment in
    subformula linking as an interaction method"
    -   K\. Chaudhuri: [_Subformula Linking as an Interaction Method_](http://chaudhuri.info/papers/itp13link.pdf) (2013)

### Formal methods in practice

-   [seL4](http://sel4.systems/) – first fully verified and open-sourced OS kernel
-   [Muen Separation Kernel](http://muen.sk/) – first open-source kernel verified for
    absence of runtime errors ([Reddit discussion](https://www.reddit.com/r/programming/comments/1sjyop/the_muen_separation_kernel_is_the_worlds_first/))
-   [CertiKOS](http://flint.cs.yale.edu/certikos/) – "advanced development of certified OS kernels"
-   [Galois, Inc.](https://galois.com) and anything they do

### Learning resources

Courses, textbooks, papers, theses, competitions, influential figures in the field.

-   [The QED Manifesto](http://www.cs.ru.nl/~freek/qed/qed.html)
-   [Formalizing 100 Theorems](http://www.cs.ru.nl/~freek/100/index.html)
-   [Verified Software Competition](http://vscomp.org/)
-   [VerifyThis](http://www.verifythis.org/) – a competition and collection of
    problems in formal verification of algorithms and software
-   [Oregon Programming Languages Summer School](https://www.cs.uoregon.edu/research/summerschool/) –
    videos of _awesome_ lectures on type theory, provers, logic, etc.; earlier
    editions only have lectures notes and slides published

    [2015](https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html),
    [2014](https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html),
    [2013](https://www.cs.uoregon.edu/research/summerschool/summer13/curriculum.html),
    [2012](https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html),
    [2011](https://www.cs.uoregon.edu/research/summerschool/summer11/curriculum.html),
    [2010](https://www.cs.uoregon.edu/research/summerschool/summer10/curriculum.html),
    [2009](https://www.cs.uoregon.edu/research/summerschool/summer09/curriculum.html),
    [2008](https://www.cs.uoregon.edu/research/summerschool/summer08/curriculum.html),
    [2007](https://www.cs.uoregon.edu/research/summerschool/summer07/curriculum.html),
    [2006](https://www.cs.uoregon.edu/research/summerschool/summer06/curriculum.html),
    [2005](https://www.cs.uoregon.edu/research/summerschool/summer05/curriculum.html)

## Type theory

Danny Gratzer's [learn-tt](https://github.com/jozefg/learn-tt) is a fantastic
resource for those interested in type and category theory. He presents all the
terrific tools, textbooks, and papers that deal with both of these in a sensible and
logical way, which is a quality that my repository will never have.

I'll only list here resources which he doesn't mention and which I personally find
interesting.

Check out the [TYPES](http://lists.seas.upenn.edu/mailman/listinfo/types-list)
mailing list as well.

### Dependent types

-   A\. Bove, P. Dybjer: [_Dependent Types at Work_](http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf)
    – introduction to programming with dependent types in Agda

## Copyright

Written in 2015 by Matěj Grabovský <matej.grabovsky at gmail>

To the extent possible under law, the author has dedicated all copyright and related
and neighboring rights to this software to the public domain worldwide. This software
is distributed without any warranty.

You should have received a copy of the CC0 Public Domain Dedication along with this
software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

<!-- vim: set et ts=4 sw=4: -->
